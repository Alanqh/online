'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

//aits-ignore
exports.RedDotTip_Generate = class RedDotTip_Generate extends mw.UIScript {
    image = undefined;
    /**
    * onStart 之前触发一次
    */
    onAwake() {
    }
};
__decorate([
    UIWidgetBind('RootCanvas/image')
], exports.RedDotTip_Generate.prototype, "image", void 0);
exports.RedDotTip_Generate = __decorate([
    UIBind('UI/RedDotTip/RedDotTip.ui')
], exports.RedDotTip_Generate);

/*
 * @Author: YuKun.Gao
 * @Date: 2023-06-30 15:49:14
 * @LastEditors: YuKun.Gao
 * @LastEditTime: 2023-07-03 14:47:11
 * @Description: file content
 * @FilePath: \CommonModule_RedDot\JavaScripts\module\redDotModule\RedDotTip.ts
 */
/**
 * AUTHOR: 逝水无痕
 * TIME: 2023.06.30-15.49.20
 */
/**
 * 红点提示UI组件
 */
class RedDotTip extends exports.RedDotTip_Generate {
    /**
     * onShow是UI的生命周期函数，被显示的时候会回调，同时会传入参数pos更新红点的位置。
     * @param pos 红点位置
     */
    onShow(pos) {
        this.image.position = pos;
    }
}

/**
 * 红点树中的节点对象，主要用来维护红点树的结构，同时维护红点UI的显示状态。
 */
class RedNode {
    /**
     * 最后一个节点。
     */
    tail;
    /**
     * 下一个节点。标识当前这个红点树路径中的下一个节点。
     */
    nextNode;
    /**
     * 当前需要渲染红点的UI组件对象
     */
    ui;
    /**
     * 红点UI对象，主要用来渲染红点。
     */
    redDotUi;
    /** 获取 UI的显示状态 当前红点是否显示*/
    getUIRedDotState;
    setShowUIRedDot;
    /** 红点节点对象池 获取渲染红点的UI，主要是用来做红点UI对象池的 */
    getRedDotUICall;
    releaseRedDotUICall;
    /**
     * 当前的z系数，用来控制红点UI的渲染顺序。
     */
    z = 0;
    /**
     * 当前节点是否显示
     */
    isVisible = false;
    /**
     * 查询是否显示，递归判断当前绑定的UI是否显示，因为可能是某个UI中的一个组件，比如ItemUI中的itemImg组件，ItemUI可能没显示，但是itemImg是显示的，所以得一层一层往上找。
     * @param ui 目标UI
     * @returns
     */
    findIsVisible(ui) {
        if (ui.parent != null) {
            if (ui.visible == false) {
                this.isVisible = false;
                return;
            }
            else {
                this.isVisible = true;
                this.findIsVisible(ui.parent);
            }
        }
    }
    /**
     * 递归查询当前需要显示红点得组件所在UI的zOrder。
     * @param ui
     */
    findZ(ui) {
        if (ui.parent != null) {
            if (this.z < ui.zOrder) {
                this.z = ui.zOrder;
            }
            this.findZ(ui.parent);
        }
    }
    /**
     * 隐藏当前红点树，此刻会释放当前红点组件，供其它红点树使用。
     * @returns
     */
    hide() {
        if (this.redDotUi == null) {
            return;
        }
        this.releaseRedDotUICall(this.redDotUi);
        this.redDotUi = null;
        return;
    }
    /**
     * 刷新当前红点树节点，主要是判断当前红点是否显示，如果显示则渲染红点UI。
     * @returns
     */
    refresh() {
        /** 当前红点已经显示 */
        if (this.getUIRedDotState(this.ui)) {
            if (this.redDotUi == null) {
                return;
            }
            this.releaseRedDotUICall(this.redDotUi);
            this.redDotUi = null;
            return;
        }
        this.findIsVisible(this.ui);
        if (!this.isVisible) {
            if (this.redDotUi == null) {
                return;
            }
            this.releaseRedDotUICall(this.redDotUi);
            this.redDotUi = null;
            return;
        }
        this.findZ(this.ui);
        this.setShowUIRedDot(this.ui);
        if (this.redDotUi == null) {
            this.redDotUi = this.getRedDotUICall();
        }
        let pos2 = Vector.zero;
        let pos = Vector.zero;
        mw.localToViewport(this.ui.tickSpaceGeometry, Vector2.zero, pos2, pos);
        mw.UIService.showUI(this.redDotUi, 0, pos);
        this.redDotUi.uiObject.zOrder = this.z + 1;
    }
}
/**
 * 红点树模块，主要用来管理红点树，新增，删除，扩容，刷新，同时维护红点UI的对象池。
 */
class RedDotModuleC extends ModuleC {
    /**
     * 所有个红点树，每个key对应一个红点树。每个红点树是一条线性的路径。
     */
    trees = new Map();
    /**
     * 红点UI对象池
     */
    redUIPool = [];
    /**
     * 正在显示的红点树
     */
    showList = new Map();
    /**
     * 等待移除的红点树
     */
    removeList = new Map();
    /**
     * 缓存需要被显示红点的UI组件，主要是为了多个红点树共用一个UI组件时，不会因为后面的树不显示而覆盖前面的显示状态。
     */
    uiRedDotState = new Map();
    /**
     * 设置指定UI组件需要显示红点。
     * @param ui UI组件
     */
    setUIShowRedDot(ui) {
        this.uiRedDotState.set(ui, true);
    }
    /**
     * 获取指定UI组件是否需要显示红点
     * @param ui UI组件
     * @returns
     */
    getUIShowRedDot(ui) {
        if (!this.uiRedDotState.has(ui))
            return false;
        return this.uiRedDotState.get(ui);
    }
    /**
     * 压入一个红点UI到对象池中
     * @param tip 红点UI
     */
    pushRedDotTip(tip) {
        mw.UIService.hideUI(tip);
        this.redUIPool.push(tip);
    }
    /**
     * 从对象池中获取一个红点UI，如果没有则创建一个新的红点UI。
     * @returns
     */
    getRedDotTip() {
        if (this.redUIPool.length > 0) {
            return this.redUIPool.shift();
        }
        let redUI = mw.UIService.create(RedDotTip);
        return redUI;
    }
    /**
     * 创建一个红点树节点
     * @param ui 需要显示红点的UI组件
     * @returns
     */
    newNode(ui) {
        let node = new RedNode();
        node.ui = ui;
        node.getRedDotUICall = this.getRedDotTip.bind(this);
        node.releaseRedDotUICall = this.pushRedDotTip.bind(this);
        node.getUIRedDotState = this.getUIShowRedDot.bind(this);
        node.setShowUIRedDot = this.setUIShowRedDot.bind(this);
        return node;
    }
    /**
     * 触发一个红点数事件
     * @param eventName 红点树事件名
     * @returns
     */
    triggerRedDotEvent(eventName) {
        if (!this.trees.has(eventName)) {
            return;
        }
        //console.error("触发事件" + eventName);
        let tree = this.trees.get(eventName);
        this.showList.set(eventName, tree);
    }
    /**
     * 移除一个红点事件
     * @param eventName 红点树事件名
     */
    removeRedDotEvent(eventName) {
        if (this.showList.has(eventName)) {
            this.hideRedDotEvent(eventName);
        }
        if (this.trees.has(eventName)) {
            this.trees.delete(eventName);
        }
    }
    /**
     * 隐藏一个红点树
     */
    hideRedDotEvent(eventName) {
        if (this.showList.has(eventName)) {
            this.removeList.set(eventName, this.showList.get(eventName));
            this.showList.delete(eventName);
        }
    }
    /**
     * 根据红点数事件名获取对应UI列表
     * @param eventName 红点树事件名
     * @returns
     */
    getRedDotUIArrsByEventName(eventName) {
        if (!this.trees.has(eventName)) {
            return [];
        }
        let tree = this.trees.get(eventName);
        let uiArrs = [];
        do {
            uiArrs.push(tree.ui);
            tree = tree.nextNode;
        } while (tree != null);
        return uiArrs;
    }
    /**
     * 根据一颗红点树，扩容一颗新的树
     * @param srcEventName 源的红点树事件名
     * @param newEventName 新的红点树事件名
     * @param concatUiArrays 继续扩容的UI组件
     * @returns
     */
    addRedDotPathByEvt(srcEventName, newEventName, ...concatUiArrays) {
        if (!this.trees.has(srcEventName)) {
            return this;
        }
        if (this.trees.has(newEventName)) {
            return this;
        }
        let tree = this.trees.get(srcEventName);
        let oldUI = [];
        do {
            oldUI.push(tree.ui);
            tree = tree.nextNode;
        } while (tree != null);
        oldUI = oldUI.concat(concatUiArrays);
        this.addRedDotPath(newEventName, ...oldUI);
    }
    /**
     * 添加一颗红点树
     * @param eventName 红点树事件名
     * @param uiArrays 需要显示红点的UI组件列表
     * @returns
     */
    addRedDotPath(eventName, ...uiArrays) {
        if (uiArrays.length <= 0)
            return this;
        let tree;
        if (this.trees.has(eventName)) {
            return this;
        }
        else {
            tree = this.newNode(uiArrays[0]);
        }
        let head = tree;
        let curNode = tree;
        for (var i = 1; i < uiArrays.length; i++) {
            let node = this.newNode(uiArrays[i]);
            curNode.nextNode = node;
            curNode = node;
        }
        head.tail = curNode;
        this.trees.set(eventName, head);
        return this;
    }
    /**
     * Tick函数，每帧调用一次。是ModuleC的生命周期函数，不要手动调用。此处的功能主要是刷新红点树。
     * @param dt
     */
    onUpdate(dt) {
        /** 刷新所有UI红点的显示状态为false */
        this.uiRedDotState.forEach((v, k) => {
            this.uiRedDotState.set(k, false);
        });
        /** 移除在待移除列表的所有红点树 */
        this.removeList.forEach((v, k) => {
            let temp = v;
            do {
                temp.hide();
                temp = temp.nextNode;
            } while (temp != null);
        });
        this.removeList.clear();
        /** 刷新目前需要显示的红点树 */
        this.showList.forEach((v, k) => {
            let temp = v;
            do {
                temp.refresh();
                temp = temp.nextNode;
            } while (temp != null);
        });
    }
}

class RedDotModuleS extends ModuleS {
}

exports.RedDotModuleC = RedDotModuleC;
exports.RedDotModuleS = RedDotModuleS;
exports.RedDotTip = RedDotTip;
//# sourceMappingURL=index.js.map
